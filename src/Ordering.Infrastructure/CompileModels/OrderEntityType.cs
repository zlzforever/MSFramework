// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using MicroserviceFramework;
using MicroserviceFramework.Domain;
using MicroserviceFramework.Serialization;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Ordering.Domain.AggregateRoots;
using Pomelo.EntityFrameworkCore.MySql.Storage.Internal;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Ordering.Infrastructure.CompileModels
{
    internal partial class OrderEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Ordering.Domain.AggregateRoots.Order",
                typeof(Order),
                baseEntityType);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(string),
                propertyInfo: typeof(EntityBase<string>).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(EntityBase<string>).GetField("_id", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                maxLength: 36);
            id.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(36)",
                    size: 36));
            id.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            id.AddAnnotation("Relational:ColumnName", "id");

            var buyerId2 = runtimeEntityType.AddProperty(
                "BuyerId2",
                typeof(string),
                propertyInfo: typeof(Order).GetProperty("BuyerId2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("<BuyerId2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 36);
            buyerId2.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(36)",
                    size: 36));
            buyerId2.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            buyerId2.AddAnnotation("Relational:ColumnName", "buyer_id2");

            var concurrencyStamp = runtimeEntityType.AddProperty(
                "ConcurrencyStamp",
                typeof(string),
                propertyInfo: typeof(Order).GetProperty("ConcurrencyStamp", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("<ConcurrencyStamp>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                concurrencyToken: true,
                maxLength: 36);
            concurrencyStamp.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(36)",
                    size: 36));
            concurrencyStamp.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            concurrencyStamp.AddAnnotation("Relational:ColumnName", "concurrency_stamp");

            var creationTime = runtimeEntityType.AddProperty(
                "CreationTime",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(CreationEntity<string>).GetProperty("CreationTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CreationEntity<string>).GetField("<CreationTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            creationTime.TypeMapping = MySqlDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                keyComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                providerValueComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "datetime(6)",
                    precision: 6));
            creationTime.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            creationTime.AddAnnotation("Relational:ColumnName", "creation_time");

            var creatorId = runtimeEntityType.AddProperty(
                "CreatorId",
                typeof(string),
                propertyInfo: typeof(CreationEntity<string>).GetProperty("CreatorId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CreationEntity<string>).GetField("<CreatorId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 36);
            creatorId.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(36)",
                    size: 36));
            creatorId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            creatorId.AddAnnotation("Relational:ColumnName", "creator_id");

            var creatorName = runtimeEntityType.AddProperty(
                "CreatorName",
                typeof(string),
                propertyInfo: typeof(CreationEntity<string>).GetProperty("CreatorName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CreationEntity<string>).GetField("<CreatorName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 256);
            creatorName.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(256)",
                    size: 256));
            creatorName.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            creatorName.AddAnnotation("Relational:ColumnName", "creator_name");

            var deleterId = runtimeEntityType.AddProperty(
                "DeleterId",
                typeof(string),
                propertyInfo: typeof(DeletionEntity<string>).GetProperty("DeleterId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(DeletionEntity<string>).GetField("<DeleterId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            deleterId.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "longtext"),
                storeTypePostfix: StoreTypePostfix.None);
            deleterId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            deleterId.AddAnnotation("Relational:ColumnName", "deleter_id");

            var deleterName = runtimeEntityType.AddProperty(
                "DeleterName",
                typeof(string),
                propertyInfo: typeof(DeletionEntity<string>).GetProperty("DeleterName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(DeletionEntity<string>).GetField("<DeleterName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            deleterName.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "longtext"),
                storeTypePostfix: StoreTypePostfix.None);
            deleterName.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            deleterName.AddAnnotation("Relational:ColumnName", "deleter_name");

            var deletionTime = runtimeEntityType.AddProperty(
                "DeletionTime",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(DeletionEntity<string>).GetProperty("DeletionTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(DeletionEntity<string>).GetField("<DeletionTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            deletionTime.TypeMapping = MySqlDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                keyComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                providerValueComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "datetime(6)",
                    precision: 6));
            deletionTime.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            deletionTime.AddAnnotation("Relational:ColumnName", "deletion_time");

            var description2 = runtimeEntityType.AddProperty(
                "Description2",
                typeof(string),
                propertyInfo: typeof(Order).GetProperty("Description2", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("<Description2>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true,
                maxLength: 2000);
            description2.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(2000)",
                    size: 2000));
            description2.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            description2.AddAnnotation("Relational:ColumnName", "description2");

            var dictJson = runtimeEntityType.AddProperty(
                "DictJson",
                typeof(IReadOnlyDictionary<string, string>),
                propertyInfo: typeof(Order).GetProperty("DictJson", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("_dictJson", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            dictJson.TypeMapping = MySqlJsonTypeMapping<string>.Default.Clone(
                comparer: new ValueComparer<IReadOnlyDictionary<string, string>>(
                    (IReadOnlyDictionary<string, string> l, IReadOnlyDictionary<string, string> r) => Defaults.JsonSerializer.Serialize(l) == Defaults.JsonSerializer.Serialize(r),
                    (IReadOnlyDictionary<string, string> v) => v == null ? 0 : Defaults.JsonSerializer.Serialize(v).GetHashCode(),
                    (IReadOnlyDictionary<string, string> v) => Defaults.JsonSerializer.Deserialize(Defaults.JsonSerializer.Serialize(v), typeof(IReadOnlyDictionary<string, string>)) as IReadOnlyDictionary<string, string>),
                keyComparer: new ValueComparer<IReadOnlyDictionary<string, string>>(
                    (IReadOnlyDictionary<string, string> l, IReadOnlyDictionary<string, string> r) => Defaults.JsonSerializer.Serialize(l) == Defaults.JsonSerializer.Serialize(r),
                    (IReadOnlyDictionary<string, string> v) => v == null ? 0 : Defaults.JsonSerializer.Serialize(v).GetHashCode(),
                    (IReadOnlyDictionary<string, string> v) => Defaults.JsonSerializer.Deserialize(Defaults.JsonSerializer.Serialize(v), typeof(IReadOnlyDictionary<string, string>)) as IReadOnlyDictionary<string, string>),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "JSON"),
                converter: new ValueConverter<IReadOnlyDictionary<string, string>, string>(
                    (IReadOnlyDictionary<string, string> x) => Defaults.JsonSerializer.Serialize(x),
                    (string x) => Defaults.JsonSerializer.Deserialize<IReadOnlyDictionary<string, string>>(x)));
            dictJson.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            dictJson.AddAnnotation("Relational:ColumnName", "dict_json");
            dictJson.AddAnnotation("Relational:ColumnType", "JSON");

            var extras = runtimeEntityType.AddProperty(
                "Extras",
                typeof(IReadOnlyCollection<OrderExtra>),
                propertyInfo: typeof(Order).GetProperty("Extras", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("_extras", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            extras.TypeMapping = MySqlJsonTypeMapping<string>.Default.Clone(
                comparer: new ValueComparer<IReadOnlyCollection<OrderExtra>>(
                    (IReadOnlyCollection<OrderExtra> l, IReadOnlyCollection<OrderExtra> r) => Defaults.JsonSerializer.Serialize(l) == Defaults.JsonSerializer.Serialize(r),
                    (IReadOnlyCollection<OrderExtra> v) => v == null ? 0 : Defaults.JsonSerializer.Serialize(v).GetHashCode(),
                    (IReadOnlyCollection<OrderExtra> v) => Defaults.JsonSerializer.Deserialize(Defaults.JsonSerializer.Serialize(v), typeof(IReadOnlyCollection<OrderExtra>)) as IReadOnlyCollection<OrderExtra>),
                keyComparer: new ValueComparer<IReadOnlyCollection<OrderExtra>>(
                    (IReadOnlyCollection<OrderExtra> l, IReadOnlyCollection<OrderExtra> r) => Defaults.JsonSerializer.Serialize(l) == Defaults.JsonSerializer.Serialize(r),
                    (IReadOnlyCollection<OrderExtra> v) => v == null ? 0 : Defaults.JsonSerializer.Serialize(v).GetHashCode(),
                    (IReadOnlyCollection<OrderExtra> v) => Defaults.JsonSerializer.Deserialize(Defaults.JsonSerializer.Serialize(v), typeof(IReadOnlyCollection<OrderExtra>)) as IReadOnlyCollection<OrderExtra>),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "JSON"),
                converter: new ValueConverter<IReadOnlyCollection<OrderExtra>, string>(
                    (IReadOnlyCollection<OrderExtra> x) => Defaults.JsonSerializer.Serialize(x),
                    (string x) => Defaults.JsonSerializer.Deserialize<IReadOnlyCollection<OrderExtra>>(x)));
            extras.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            extras.AddAnnotation("Relational:ColumnName", "extras");
            extras.AddAnnotation("Relational:ColumnType", "JSON");

            var isDeleted = runtimeEntityType.AddProperty(
                "IsDeleted",
                typeof(bool),
                propertyInfo: typeof(DeletionEntity<string>).GetProperty("IsDeleted", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(DeletionEntity<string>).GetField("<IsDeleted>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isDeleted.TypeMapping = MySqlBoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    (bool v1, bool v2) => v1 == v2,
                    (bool v) => v.GetHashCode(),
                    (bool v) => v));
            isDeleted.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            isDeleted.AddAnnotation("Relational:ColumnName", "is_deleted");

            var lastModificationTime = runtimeEntityType.AddProperty(
                "LastModificationTime",
                typeof(DateTimeOffset?),
                propertyInfo: typeof(ModificationEntity<string>).GetProperty("LastModificationTime", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ModificationEntity<string>).GetField("<LastModificationTime>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            lastModificationTime.TypeMapping = MySqlDateTimeOffsetTypeMapping.Default.Clone(
                comparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                keyComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                providerValueComparer: new ValueComparer<DateTimeOffset?>(
                    (Nullable<DateTimeOffset> v1, Nullable<DateTimeOffset> v2) => v1.HasValue && v2.HasValue && ((DateTimeOffset)v1).EqualsExact((DateTimeOffset)v2) || !v1.HasValue && !v2.HasValue,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? ((DateTimeOffset)v).GetHashCode() : 0,
                    (Nullable<DateTimeOffset> v) => v.HasValue ? (Nullable<DateTimeOffset>)(DateTimeOffset)v : default(Nullable<DateTimeOffset>)),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "datetime(6)",
                    precision: 6));
            lastModificationTime.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            lastModificationTime.AddAnnotation("Relational:ColumnName", "last_modification_time");

            var lastModifierId = runtimeEntityType.AddProperty(
                "LastModifierId",
                typeof(string),
                propertyInfo: typeof(ModificationEntity<string>).GetProperty("LastModifierId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ModificationEntity<string>).GetField("<LastModifierId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            lastModifierId.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "longtext"),
                storeTypePostfix: StoreTypePostfix.None);
            lastModifierId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            lastModifierId.AddAnnotation("Relational:ColumnName", "last_modifier_id");

            var lastModifierName = runtimeEntityType.AddProperty(
                "LastModifierName",
                typeof(string),
                propertyInfo: typeof(ModificationEntity<string>).GetProperty("LastModifierName", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(ModificationEntity<string>).GetField("<LastModifierName>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            lastModifierName.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                keyComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "longtext"),
                storeTypePostfix: StoreTypePostfix.None);
            lastModifierName.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            lastModifierName.AddAnnotation("Relational:ColumnName", "last_modifier_name");

            var listJson = runtimeEntityType.AddProperty(
                "ListJson",
                typeof(IReadOnlyCollection<string>),
                propertyInfo: typeof(Order).GetProperty("ListJson", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("_listJson", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            listJson.TypeMapping = MySqlJsonTypeMapping<string>.Default.Clone(
                comparer: new ValueComparer<IReadOnlyCollection<string>>(
                    (IReadOnlyCollection<string> l, IReadOnlyCollection<string> r) => Defaults.JsonSerializer.Serialize(l) == Defaults.JsonSerializer.Serialize(r),
                    (IReadOnlyCollection<string> v) => v == null ? 0 : Defaults.JsonSerializer.Serialize(v).GetHashCode(),
                    (IReadOnlyCollection<string> v) => Defaults.JsonSerializer.Deserialize(Defaults.JsonSerializer.Serialize(v), typeof(HashSet<string>)) as IReadOnlyCollection<string>),
                keyComparer: new ValueComparer<IReadOnlyCollection<string>>(
                    (IReadOnlyCollection<string> l, IReadOnlyCollection<string> r) => Defaults.JsonSerializer.Serialize(l) == Defaults.JsonSerializer.Serialize(r),
                    (IReadOnlyCollection<string> v) => v == null ? 0 : Defaults.JsonSerializer.Serialize(v).GetHashCode(),
                    (IReadOnlyCollection<string> v) => Defaults.JsonSerializer.Deserialize(Defaults.JsonSerializer.Serialize(v), typeof(HashSet<string>)) as IReadOnlyCollection<string>),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "JSON"),
                converter: new ValueConverter<IReadOnlyCollection<string>, string>(
                    (IReadOnlyCollection<string> x) => Defaults.JsonSerializer.Serialize(x),
                    (string x) => Defaults.JsonSerializer.Deserialize(x, typeof(HashSet<string>)) as IReadOnlyCollection<string>));
            listJson.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            listJson.AddAnnotation("Relational:ColumnName", "list_json");
            listJson.AddAnnotation("Relational:ColumnType", "JSON");

            var operatorId = runtimeEntityType.AddProperty(
                "OperatorId",
                typeof(int?),
                nullable: true);
            operatorId.TypeMapping = MySqlIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                keyComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)),
                providerValueComparer: new ValueComparer<int?>(
                    (Nullable<int> v1, Nullable<int> v2) => v1.HasValue && v2.HasValue && (int)v1 == (int)v2 || !v1.HasValue && !v2.HasValue,
                    (Nullable<int> v) => v.HasValue ? (int)v : 0,
                    (Nullable<int> v) => v.HasValue ? (Nullable<int>)(int)v : default(Nullable<int>)));
            operatorId.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            operatorId.AddAnnotation("Relational:ColumnName", "operator_id");

            var status = runtimeEntityType.AddProperty(
                "Status",
                typeof(OrderStatus),
                propertyInfo: typeof(Order).GetProperty("Status", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("<Status>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 20);
            status.TypeMapping = MySqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<OrderStatus>(
                    (OrderStatus v1, OrderStatus v2) => object.Equals(v1, v2),
                    (OrderStatus v) => v.GetHashCode(),
                    (OrderStatus v) => v),
                keyComparer: new ValueComparer<OrderStatus>(
                    (OrderStatus v1, OrderStatus v2) => object.Equals(v1, v2),
                    (OrderStatus v) => v.GetHashCode(),
                    (OrderStatus v) => v),
                providerValueComparer: new ValueComparer<string>(
                    (string v1, string v2) => v1 == v2,
                    (string v) => v.GetHashCode(),
                    (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "varchar(20)",
                    size: 20),
                converter: new ValueConverter<OrderStatus, string>(
                    (OrderStatus v) => v.ToString(),
                    (string v) => string.IsNullOrEmpty(v) ? null : Enumeration.FromValue<OrderStatus>(v)),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<OrderStatus, string>(
                    JsonStringReaderWriter.Instance,
                    new ValueConverter<OrderStatus, string>(
                        (OrderStatus v) => v.ToString(),
                        (string v) => string.IsNullOrEmpty(v) ? null : Enumeration.FromValue<OrderStatus>(v))));
            status.AddAnnotation("MySql:ValueGenerationStrategy", MySqlValueGenerationStrategy.None);
            status.AddAnnotation("Relational:ColumnName", "status");

            var key = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key);

            var index = runtimeEntityType.AddIndex(
                new[] { creationTime });

            var index0 = runtimeEntityType.AddIndex(
                new[] { operatorId });

            return runtimeEntityType;
        }

        public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
        {
            var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("OperatorId") },
                principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
                principalEntityType);

            var @operator = declaringEntityType.AddNavigation("Operator",
                runtimeForeignKey,
                onDependent: true,
                typeof(User),
                propertyInfo: typeof(Order).GetProperty("Operator", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Order).GetField("<Operator>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

            return runtimeForeignKey;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "ordering_order");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
